---
name: domain-modeling
description: "Use when: (1) the same term means different things to different actors, (2) a type is growing too many properties or has boolean flags for state, (3) spec tables have complex cross-cutting rules, or (4) business concepts need to be decomposed into types"
disable-model-invocation: false
---

# ドメインモデリング

新しい機能（概念）を追加する際に、ドメインモデルの**新規作成 or 再構築**が必要かを検知・判断するためのスキル。

関連: `robust-code.md`（型による予防的設計、完全性）

---

## 検知: モデリングが必要なサイン

### コンテキスト境界の兆候（言語ゲーム）

同じ言葉でも**アクターの目的が異なれば意味とルールが変わる**。この兆候があれば、コンテキスト分割（=モデル新規作成）が必要。

- 同じ用語がアクターごとに異なる意味で使われている
- 1つの型に異なるアクターのルールが混在している
- 新機能の追加先が「どのアクターの目的か」で迷う

### 再構築の兆候（脱構築）

既存モデルに以下のコードの匂いがあれば、再構築が必要。

- **Fat Model**: プロパティが増え続け、肥大化している
- **boolean フラグで状態管理**: `isApproved`, `isCancelled`, `isShipped` が混在
- **スタンプ結合**: メソッドがオブジェクト全体を受け取るが一部しか使わない
- **Shotgun Parsing**: 同じバリデーション（`if (x != null)`）が複数箇所に散在 → モデルが Always-Valid でない
- **名前と振る舞いの乖離**: 型名が実態を表していない、曖昧な `XxxService`
- **命名の複文化**: メソッド名を正確に書くと「A の場合は〜し、B の場合は〜する」になる
- **状態による不変条件の変化**: ステータスごとに必須項目や可能な操作が異なる

### 検知を妨げるバイアス

- **物理エンティティバイアス**: 目に見えるモノに引っ張られ、全属性を1クラスに詰め込む
- **技術スキーマ**: すべてを CRUD / DB テーブルで解決しようとする
- **言葉の無意識な翻訳**: ドメインエキスパートの言葉を自分の知識に置き換えてしまう
- **正常系バイアス**: 正常系に集中し、異常系の制約を後回しの if 文で対処 → 制約自体がドメイン概念（Policy/Specification）であることを見落とす

> **「違和感」はバイアスのズレを示すサイン。** 聞き慣れない言葉、使い方の違いを感じたら、わかったつもりにならず確認する。

---

## 判断: 新規作成 or 再構築

### 新規作成

- 既存モデルに該当する概念がない
- 既存の型に追加すると**アクターの目的が混在**する
- 新しい不変条件が既存型の不変条件と矛盾する
- **ライフサイクルの段階で関心事が変わる**（例: 書籍の執筆→マーケ→出荷で必要な振る舞いが全く異なる）

### 再構築

- 上記「再構築の兆候」に該当する
- 新概念の追加が既存モデルの**直交性を壊す**（1変更が複数仕様に波及する）

### よくある誤り

- **DRY の誤適用 / 統一モデル志向**: 同じ名前・似たコードだからと異なるコンテキストの概念を統合 → 神クラス化。DRY はコードの重複ではなく**ビジネス知識の重複**を防ぐ原則
- **過剰分割**: 同じユビキタス言語の凝集性の高いロジックを分けすぎ → 1変更に複数コンテキストの修正が必要になる

### 判断に迷ったら

- 物理的なモノではなく**目的**で考える（目的論的抽象 > 存在論的抽象）
- 「みんなは〇〇と呼んでるけど、実は xx では？」と問い直す
- 目を閉じて「見えない概念」（法的責任、権利、状態遷移）に着目する

---

## 手法: コンテキスト境界の発見

1. **アクターを列挙する**: この業務に関わる人・システムは誰か
2. **各アクターの目的を明確にする**: 何を達成したいのか
3. **同じ言葉の意味の違いを探す**: 同一用語がアクターごとに異なる意味で使われていないか
4. **目的ごとにルールを分離する**: 意味が異なる言葉は別コンテキストに属する

---

## 手法: 隠れた概念の発見

- **モノ→コト**: 物理的な「モノ」ではなく「イベント（コト）」に着目する。イベント間の因果関係から Policy が浮かび上がる（例: 「申込」イベント → 「決済実行」コマンドを繋ぐルール = 決済ポリシー）
- **if 文から Policy/Specification を抽出**: 散在する条件分岐（`if (totalCargo + newCargo > capacity * 1.1)`）の背後に暗黙のドメイン概念が隠れている → `OverbookingPolicy` として明示化

---

## 手法: 再構築のテクニック

- **目的ごとに解体**: 1つの物理エンティティを目的別の概念に分割する（例: 「商品」→ 販売目的の「所有権」、配送目的の「貨物」、会計目的の「棚卸資産」）
- **状態 → 別の型に分離**: boolean flags / status code → 状態ごとの Discriminated Union（Always-Valid Model）
- **振る舞いから逆算してデータを抽出**: スタンプ結合を解消し、真に必要なデータだけを値オブジェクトとして切り出す
- **曖昧な Service → 具体的な役割**: `UserDomainService` → `UserDuplicationChecker`, `UserApprover`

---

## 手法: 型の粒度設計

### Step 1: 出力は列挙可能か？

仕様で有限個の選択肢として明示されているか → **Yes**: Step 3 へ / **No**: Step 2 へ

### Step 2: 結果カテゴリに差異があるか？

不変条件・後続処理・境界値のいずれかが異なるか → **Yes**: 区分を作成 / **No**: 区分化不要（概念的に状態が分かれていても**振る舞いに差異がなければ型を分けない**）

### Step 3: 型定義方法の選択

- **A: 入力をORで区分** — 各ケースで異なる処理（分岐ロジックが複雑）
- **B: 中間の区分型を導入** — 全ケースで同じ処理（結果の種類を表現）

### Step 4: 固定列挙 vs パラメータ化

| 固定列挙 | パラメータ化 |
|----------|--------------|
| 有限・確定、変更頻度低 | 多数・頻繁な変更、均質な処理 |
| コードで定義 | データで定義 |

> 定義した区分は**同値分割法の同値クラス**としてテストに直接活用できる。

---

## 手法: 仕様の直交性チェック

機能（仕様の軸）同士が**無関係に独立して動作する**状態を目指す。

| 直交性 | 複雑性の増加 |
|--------|------------|
| **高い**（独立） | **加算的**: A + B + C |
| **低い**（依存） | **乗算的**: A × B × C |

**直交性が低い兆候**: 巨大なマトリクス仕様表、1変更が複数仕様に波及、例外だらけ。

仕様表が与えられた場合は**隠れた意図を逆算**する:
1. パターンの背後にある「なぜこの値なのか」を問う
2. 独立した軸（直交する関心事）を見つける
3. 各軸を個別の型・関数として分離する
4. 組み合わせで元の仕様表を再現できるか検証する

---

コード例・参考資料: @reference.md
