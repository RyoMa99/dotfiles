---
name: domain-modeling
description: "Use when: (1) the same term means different things to different actors, (2) a type is growing too many properties or has boolean flags for state, (3) spec tables have complex cross-cutting rules, or (4) business concepts need to be decomposed into types"
disable-model-invocation: false
---

# ドメインモデリング

新しい機能（概念）を追加する際に、ドメインモデルの**検知・判断・構築・検証**を一貫して行うスキル。

関連: `robust-code.md`（型による予防的設計、完全性）

---

## 検知: モデリングが必要なサイン

### コンテキスト境界の兆候（言語ゲーム）

同じ言葉でも**アクターの目的が異なれば意味とルールが変わる**。この兆候があれば、コンテキスト分割（=モデル新規作成）が必要。

- 同じ用語がアクターごとに異なる意味で使われている
- 1つの型に異なるアクターのルールが混在している
- 新機能の追加先が「どのアクターの目的か」で迷う

### 再構築の兆候（脱構築）

既存モデルに以下のコードの匂いがあれば、再構築が必要。

- **Fat Model**: プロパティが増え続け、肥大化している
- **boolean フラグで状態管理**: `isApproved`, `isCancelled`, `isShipped` が混在
- **スタンプ結合**: メソッドがオブジェクト全体を受け取るが一部しか使わない
- **Shotgun Parsing**: 同じバリデーション（`if (x != null)`）が複数箇所に散在 → モデルが Always-Valid でない
- **名前と振る舞いの乖離**: 型名が実態を表していない、曖昧な `XxxService`
- **命名の複文化**: メソッド名を正確に書くと「A の場合は〜し、B の場合は〜する」になる
- **状態による不変条件の変化**: ステータスごとに必須項目や可能な操作が異なる

### 検知を妨げるバイアス

- **物理エンティティバイアス**: 目に見えるモノに引っ張られ、全属性を1クラスに詰め込む
- **技術スキーマ**: すべてを CRUD / DB テーブルで解決しようとする
- **言葉の無意識な翻訳**: ドメインエキスパートの言葉を自分の知識に置き換えてしまう
- **正常系バイアス**: 正常系に集中し、異常系の制約を後回しの if 文で対処 → 制約自体がドメイン概念（Policy/Specification）であることを見落とす

> **「違和感」はバイアスのズレを示すサイン。** 聞き慣れない言葉、使い方の違いを感じたら、わかったつもりにならず確認する。

---

## 判断: 新規作成 or 再構築

### 新規作成

- 既存モデルに該当する概念がない
- 既存の型に追加すると**アクターの目的が混在**する
- 新しい不変条件が既存型の不変条件と矛盾する
- **ライフサイクルの段階で関心事が変わる**（例: 書籍の執筆→マーケ→出荷で必要な振る舞いが全く異なる）

### 再構築

- 上記「再構築の兆候」に該当する
- 新概念の追加が既存モデルの**直交性を壊す**（1変更が複数仕様に波及する）

### よくある誤り

- **DRY の誤適用 / 統一モデル志向**: 同じ名前・似たコードだからと異なるコンテキストの概念を統合 → 神クラス化。DRY はコードの重複ではなく**ビジネス知識の重複**を防ぐ原則
- **過剰分割**: 同じユビキタス言語の凝集性の高いロジックを分けすぎ → 1変更に複数コンテキストの修正が必要になる

### 判断に迷ったら

- 物理的なモノではなく**目的**で考える（目的論的抽象 > 存在論的抽象）
- 「みんなは〇〇と呼んでるけど、実は xx では？」と問い直す
- 目を閉じて「見えない概念」（法的責任、権利、状態遷移）に着目する

---

## 手法: コンテキスト境界の発見

1. **アクターを列挙する**: この業務に関わる人・システムは誰か
2. **各アクターの目的を明確にする**: 何を達成したいのか
3. **同じ言葉の意味の違いを探す**: 同一用語がアクターごとに異なる意味で使われていないか
4. **目的ごとにルールを分離する**: 意味が異なる言葉は別コンテキストに属する

---

## 手法: 隠れた概念の発見

- **モノ→コト**: 物理的な「モノ」ではなく「イベント（コト）」に着目する。イベント間の因果関係から Policy が浮かび上がる（例: 「申込」イベント → 「決済実行」コマンドを繋ぐルール = 決済ポリシー）
- **if 文から Policy/Specification を抽出**: 散在する条件分岐（`if (totalCargo + newCargo > capacity * 1.1)`）の背後に暗黙のドメイン概念が隠れている → `OverbookingPolicy` として明示化

---

## 手法: 再構築のテクニック

- **目的ごとに解体**: 1つの物理エンティティを目的別の概念に分割する（例: 「商品」→ 販売目的の「所有権」、配送目的の「貨物」、会計目的の「棚卸資産」）
- **状態 → 別の型に分離**: boolean flags / status code → 状態ごとの Discriminated Union（Always-Valid Model）
- **振る舞いから逆算してデータを抽出**: スタンプ結合を解消し、真に必要なデータだけを値オブジェクトとして切り出す
- **曖昧な Service → 具体的な役割**: `UserDomainService` → `UserDuplicationChecker`, `UserApprover`

---

## 手法: 型の粒度設計

### Step 1: 出力は列挙可能か？

仕様で有限個の選択肢として明示されているか → **Yes**: Step 3 へ / **No**: Step 2 へ

### Step 2: 結果カテゴリに差異があるか？

不変条件・後続処理・境界値のいずれかが異なるか → **Yes**: 区分を作成 / **No**: 区分化不要（概念的に状態が分かれていても**振る舞いに差異がなければ型を分けない**）

### Step 3: 型定義方法の選択

- **A: 入力をORで区分** — 各ケースで異なる処理（分岐ロジックが複雑）
- **B: 中間の区分型を導入** — 全ケースで同じ処理（結果の種類を表現）

### Step 4: 固定列挙 vs パラメータ化

| 固定列挙 | パラメータ化 |
|----------|--------------|
| 有限・確定、変更頻度低 | 多数・頻繁な変更、均質な処理 |
| コードで定義 | データで定義 |

> 定義した区分は**同値分割法の同値クラス**としてテストに直接活用できる。

---

## 手法: 仕様の直交性チェック

機能（仕様の軸）同士が**無関係に独立して動作する**状態を目指す。

| 直交性 | 複雑性の増加 |
|--------|------------|
| **高い**（独立） | **加算的**: A + B + C |
| **低い**（依存） | **乗算的**: A × B × C |

**直交性が低い兆候**: 巨大なマトリクス仕様表、1変更が複数仕様に波及、例外だらけ。

仕様表が与えられた場合は**隠れた意図を逆算**する:
1. パターンの背後にある「なぜこの値なのか」を問う
2. 独立した軸（直交する関心事）を見つける
3. 各軸を個別の型・関数として分離する
4. 組み合わせで元の仕様表を再現できるか検証する

---

## 手法: Aggregate 境界の判断

### 基本原則

1 Aggregate = 1 トランザクション。集約外への参照は ID のみ。

### 境界の判断ヒューリスティック

「独立したライフサイクル」だけでは判断しきれない場面で、以下の基準を併用する。

- **ロック競合テスト**: 参照先エンティティ X の属性変更が、参照元 Y の全件ロード+ロックを強制する構造になっていないか？ → 強制される場合、X は別 Aggregate に分離する（例: Tag 名変更時に全 Note をロックする必要がある → Tag は独立 Aggregate）
- **削除の連鎖テスト**: 親が削除されたとき子も消えるべきか？ → Yes なら同一 Aggregate の子エンティティ、No なら別 Aggregate
- **多対多の参照**: Aggregate 内部には中間テーブル相当の値オブジェクト（ID + 付帯情報）を持たせ、参照先の実体は持たない（例: `AttachedTag(tagId, confidence)` を Note 内に保持、Tag 実体は別）

### 有方向リンクとバックリンク

グラフ構造（Note→Note のリンク）を持つドメインで、逆引き（バックリンク）が必要な場合:
- ドメインモデルに双方向参照を持たせず、**ソース側 Aggregate にのみリンク情報を保持**する
- バックリンクは **CQRS のクエリサービス**（DB の `WHERE target_id = ?`）で取得する
- 双方向参照はロック競合とメモリ肥大化の温床になる

### 状態型分離時の dual-factory

状態を sealed interface / Discriminated Union で型分離した場合、インスタンス生成に2つのファクトリが必要:

- **`create()`**: ユーザー入力から新規作成。バリデーション付き。ドメインイベントを蓄積
- **`reconstruct()`**: DB から復元。バリデーションなし（DB に入っている時点で検証済み）。status 文字列から適切な型にマッピング

`reconstruct()` はインフラ層の Repository 実装からのみ呼び出す。ユースケース層からは `create()` のみ使用する。

---

## 手法: NotebookLM によるドメインモデル検証

`/notebooklm` スキル（`notebooklm-py` CLI）で文献ノートブックに問い合わせる。フェーズごとに異なるノートブックを使い分ける。

### Phase 1: モデリング中 — DDD ノートブック

**ノートブック ID**: `593bbb11-cb90-4a81-a934-9cce0474a8d5`（DDD）

Bounded Context の分割、Aggregate 境界、状態遷移設計など、ドメインモデルの構造に関する設計課題を問い合わせる。

```bash
notebooklm ask "質問内容" --notebook 593bbb11-cb90-4a81-a934-9cce0474a8d5
```

**いつ使うか:**
- 初期設計: Bounded Context 分割、コンテキストマップ、Aggregate 設計
- モデル改善: 既存モデルの再構築兆候を検知した際の設計方針検証
- 判断の裏付け: 複数の設計選択肢がある場合の根拠確認

**質問の流れ（初期設計の場合）:**
1. Bounded Context の分割案（機能一覧を添えて）
2. 各コンテキスト内の Aggregate 境界（エンティティ一覧と関係を添えて）
3. ドメインイベントと状態遷移の型設計
4. Repository 層の実装パターン（言語・フレームワーク固有）

### Phase 2: モデリング後 — 別視点からの設計レビュー

ドメインモデルが固まった後、実装に移る前に別の視座から設計を揺さぶる。DDD の枠内では見えない改善点（並行性、イベント配信、読み書き分離）を発見するためのフェーズ。

**ノートブック ID**: `17a88c4a-8e2d-46b8-9cda-ffd6a7f84519`（CQRS/ES）

```bash
notebooklm ask "質問内容" --notebook 17a88c4a-8e2d-46b8-9cda-ffd6a7f84519
```

**いつ使うか:**
- ドメインイベントを使う設計が確定した後（イベント配信の信頼性・パターン選定）
- 1つの集約に複数の非同期プロセスが書き込む構造が見えた時（ロック競合の予兆）
- 読み取りと書き込みのアクセスパターンが大きく異なる時

**問いの例:**
- 「この集約設計で、AI の非同期処理3つが並行更新する。楽観ロック競合を避ける軽量なアプローチは？」
- 「ドメインイベントを ApplicationEventPublisher で発行しているが、信頼性の問題はないか？」
- 「この Read/Write パターンに対して CQRS の Read Model 分離は妥当か？Event Sourcing まで必要か？」

### 共通ルール

1つの質問に**前提条件（既に決まった設計）+ 具体的な問い**を含める。会話は `notebooklm ask` で継続できるが、明示的に新規セッションを始めたい場合は `--new` フラグを使う。

**重要**: 1回の回答で満足せず、回答の曖昧な点や追加の設計課題について**連続質問で深掘り**する。各回答を統合して設計書（`docs/design/`）にまとめる。

---

コード例・参考資料: @reference.md
