---
name: domain-modeling
description: "Use when designing domain models with unclear concepts or complex business rules"
disable-model-invocation: false
---

# ドメインモデリング

「Domain Modeling Made Functional」に基づくドメイン記述手法。kawasima氏による解説を参考。

関連: `robust-code.md` ルール（型による予防的設計、完全性）

---

## 核心思想

> 業務ルールを構造として、**コード以前のレベルで明確にする**

ドメイン記述ミニ言語を使って仕様を整理し、それを型に落とし込む。

---

## 意図の発見

要求文書の WHY（背景・意図）は**実装設計に直接影響する**。

| 分類 | 説明 | 例 |
|------|------|-----|
| **存在論的抽象** | 自明な分類（見た目で分かる） | 「大人」「子供」「シニア」 |
| **目的論的抽象** | ビジネス目的に基づく分類 | 「基本料金に対する顧客区分割引」 |

**目的論的抽象を発見する**ことで、仕様を少数の直交した軸に分解できる。

### 仕様表のリバースエンジニアリング

既存の仕様表が与えられた場合、**隠れた意図を逆算**する:

1. 仕様表を眺め、パターンの背後にある「なぜこの値なのか」を問う
2. 独立した軸（直交する関心事）を見つける
3. 各軸を個別の型・関数として分離する
4. 組み合わせで元の仕様表を再現できるか検証する

---

## 仕様の直交性

機能（仕様の軸）同士が**無関係に独立して動作する**状態。

| 直交性 | 複雑性の増加 | 例 |
|--------|------------|-----|
| **高い**（独立） | **加算的**: A + B + C | 顧客区分割引と時間帯割引が独立 |
| **低い**（依存） | **乗算的**: A × B × C | 顧客種別と時間帯の全組み合わせが個別定義 |

**直交性が低い兆候**: 巨大なマトリクス仕様表、1変更が複数仕様に波及、例外だらけ。

---

## 基本記法

| 記号 | 意味 | 例 |
|------|------|-----|
| `AND` | すべて必須 | `顧客 = 氏名 AND 連絡先` |
| `OR` | いずれか1つ | `連絡先 = メール OR 電話` |
| `->` | 入力から出力への変換 | `注文を承認する = 未承認注文 -> 承認済み注文` |
| `?` | オプション（使用注意） | `ニックネーム?` |

### データ定義の3段階

1. **単純な値**: `名前 = 文字列 (2〜100文字)`
2. **複合データ（AND）**: `顧客 = 氏名 AND 連絡先 AND 住所`
3. **コレクション**: `商品リスト = List<商品> (1件以上)`

---

## 5つのベストプラクティス

1. **フラグ廃止 → OR導入**: `boolean` フラグを直和型に置き換え、不正な状態の組み合わせを防止
2. **ステータスコード廃止 → 型と遷移の明示**: 数値コードではなく型で状態を定義し、関数シグネチャで遷移を表現
3. **条件判定に名前付与**: マジックナンバーを区分型に変換
4. **「ほぼ同じdata」の整理**: 必須項目差分→ANDで合成、局所的選択肢→ORに閉じ込め、段階の違い→別の型
5. **不変条件設計**: 「連絡先がない顧客は許容しない」等の制約を型で強制

---

## 振る舞い定義

基本形は `入力 -> 出力`。成功と失敗はORで明示する。

```
検証する = 未検証データ -> 検証済みデータ OR 検証エラー
```

**全域性**: 例外に頼らず、すべての入力に対して出力が保証される。OR と List の使い分け: 排他的選択は OR、複数同時保持は List。

---

## 型の粒度設計: 4段階の判断フロー

### Step 1: 出力は列挙可能か？

仕様で有限個の選択肢として明示されているか → **Yes**: Step 3 へ / **No**: Step 2 へ

### Step 2: 結果カテゴリに差異があるか？

不変条件・後続処理・境界値のいずれかが異なるか → **Yes**: 区分を作成 / **No**: 区分化不要

### Step 3: 型定義方法の選択

- **A: 入力をORで区分** — 各ケースで異なる処理（分岐ロジックが複雑）
- **B: 中間の区分型を導入** — 全ケースで同じ処理（結果の種類を表現）

### Step 4: 固定列挙 vs パラメータ化

| 固定列挙 | パラメータ化 |
|----------|--------------|
| 有限・確定、変更頻度低 | 多数・頻繁な変更、均質な処理 |
| コードで定義 | データで定義 |

> 定義した区分は**同値分割法の同値クラス**としてテストに直接活用できる。

---

詳細なコード例・チェックリスト・参考資料: @reference.md
