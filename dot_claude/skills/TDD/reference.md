# TDD Reference

詳細なテスト原則とパターンのリファレンス。

## テストの信頼性（t_wada）

信頼できるテストとは「嘘がないテスト」。嘘には2種類ある。

### 偽陽性（False Positive）を避ける

**コードは正しいのにテストが失敗する**

| パターン | 説明 | 対策 |
|----------|------|------|
| Flaky Test | 結果が不安定 | 時間・ランダム性への依存を排除 |
| Brittle Test | 実装変更で壊れる | 振る舞いをテスト、詳細に依存しない |

### 偽陰性（False Negative）を避ける

**バグがあるのにテストが成功する**

| パターン | 説明 | 対策 |
|----------|------|------|
| カバレッジ不足 | テストが足りない | テストリストで網羅性確保 |
| skipされたテスト | 実行されない | 定期的にskipを解消 |

---

## テストサイズ（Small / Medium / Large）

「単体テスト」「結合テスト」は定義がブレる。**サイズで分類**する。

| サイズ | 制約 | 速度 | 例 |
|--------|------|------|-----|
| **Small** | 単一プロセス、外部アクセスなし | 最速 | ドメインロジック |
| **Medium** | 単一マシン、ローカルDB可 | 中程度 | Fake DBでのRepository |
| **Large** | 制約なし | 遅い | E2E |

### 推奨配置

```
ドメインロジック    → Small（最優先で増やす）
Controller/Service → Small（テストダブル使用）
Repository         → Medium（Fake使用）
E2E               → Large（最小限に）
```

### テストピラミッド

```
        /\       Large（少）
       /  \
      /----\     Medium
     /      \
    /--------\   Small（多）
```

逆三角形（E2Eが多い）は避ける。遅く不安定になる。

---

## テスト設計の原則

### ✅ DO: ユーザーが見える動作をテスト

```typescript
// GOOD: 動作をテスト
it('ログインボタンをクリックするとダッシュボードに遷移する', () => {
  render(<LoginForm />);
  fireEvent.click(screen.getByRole('button', { name: 'ログイン' }));
  expect(screen.getByText('ダッシュボード')).toBeInTheDocument();
});
```

### ❌ DON'T: 実装の詳細をテスト

```typescript
// BAD: 実装詳細をテスト（リファクタで壊れやすい）
it('setStateが呼ばれる', () => {
  const setState = jest.fn();
  // ...
  expect(setState).toHaveBeenCalledWith({ loggedIn: true });
});
```

### テスト間の独立性

- 各テストは独立して実行可能であること
- テスト間で状態を共有しない
- 実行順序に依存しない

```typescript
// GOOD: 各テストが独立
describe('UserService', () => {
  beforeEach(() => {
    // 各テストの前にリセット
    database.reset();
  });

  it('ユーザーを作成できる', () => { /* ... */ });
  it('ユーザーを取得できる', () => { /* ... */ });
});
```

---

## レガシーコードへのTDD適用

テストのない既存コードを改善する場合の戦略（t_wada）。

### ジレンマと解決

> テストがないと安全に変更できない。
> しかしテストを書くにはコードを変更する必要がある。

**解決**: 段階的にSeam（継ぎ目）を作り、テスト可能にする。

### Step 1: リクエスト/レスポンスレベルから

```
実装から距離を取りつつ、安定したテストを書ける
```

- 完全一致を求めず、簡潔なアサーションから開始
- 入出力の関係をテスト（実装詳細に依存しない）

### Step 2: Seam（継ぎ目）を作る

依存性を外部から注入可能にする：

```typescript
// BEFORE: テスト困難
function generateReport() {
  const now = new Date();
  const data = fetchFromDatabase();
  return format(data, now);
}

// AFTER: テスト可能
function generateReport(
  now: Date = new Date(),
  fetcher: () => Data = fetchFromDatabase
) {
  const data = fetcher();
  return format(data, now);
}

// テスト時: 決定的な値を注入
generateReport(new Date('2024-01-01'), () => mockData);
```

### Step 3: Extract戦略

```
1. 現状の動作をテストで記録（特性テスト）
2. テスト可能なコードを段階的に抽出
3. 抽出したコードにTDDを適用
4. 元のコードを抽出したコードに置き換え
```

### ドメインとインフラの分離

```
┌─────────────────────────────────────┐
│  インフラ層（テスト困難）           │
│  - HTTP/DB/外部API                  │
└─────────────────────────────────────┘
              ↓ 依存
┌─────────────────────────────────────┐
│  ドメイン層（テスト容易）           │
│  - ビジネスロジック                 │
│  - TDDで段階的に成長                │
└─────────────────────────────────────┘
```

**ドメインをインフラから分離し、ドメインにTDDを適用する。**

---

## カバレッジ目標

| 種別 | 目標 |
|------|------|
| 全体 | 80% 以上 |
| 新規コード | 90% 以上 |
| クリティカルパス | 100% |
