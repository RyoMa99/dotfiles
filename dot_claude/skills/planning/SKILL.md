---
name: planning
description: ラフなアイデアを段階的な対話と複数アプローチの比較を通じて、構造化された実装計画に変換する。タスク管理システムで進捗を追跡。
disable-model-invocation: true
---

# Planning Skill

## When to Use This Skill

Trigger when user:
- `/planning` または `/plan` コマンドを実行
- 「計画を立てて」「設計して」「どう実装すべきか」と質問
- 新機能の実装やリファクタリングを依頼
- 曖昧な要望を具体化したい場合

## 概要

このスキルは、ユーザーのラフなアイデアや要望を、段階的な対話を通じて明確な実装計画に変換し、タスク管理システムに登録して進捗を追跡します。

**実装は必ず `/TDD` スキルを通じて行う。**

## 実行手順

### Phase 1: 目的の明確化

ユーザーの要望を受け取ったら、以下を確認する質問を**1つずつ**行う：

1. **解決したい課題は何か？** - 技術的な実装ではなく、ビジネス/ユーザー視点での目的
2. **成功の定義は？** - 何が達成されれば完了とみなせるか
3. **制約条件は？** - 時間、技術スタック、既存システムとの互換性など

### Phase 1.5: コードベース調査（Serena + grepai）

**⚠️ 既存プロジェクトの場合は必須**

2つのツールを使い分けてコードベースを調査する：

```
┌─────────────────────────────────────────────────────────────┐
│  ツールの使い分け                                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  【Serena】シンボルベースの調査                              │
│  ・プロジェクト構造の把握                                    │
│  ・具体的なクラス/関数の定義・参照を追跡                    │
│  ・影響範囲の特定                                            │
│                                                             │
│  【grepai】セマンティック（意味）ベースの調査                │
│  ・「認証処理」「エラーハンドリング」等の概念検索           │
│  ・類似パターンの発見                                        │
│  ・既存実装のベストプラクティス調査                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### Step 1: 全体構造の把握（Serena）

```
mcp__serena__get_symbols_overview
→ プロジェクト全体の構造を把握
```

#### Step 2: 関連概念の検索（grepai）

```bash
grepai search "実装したい機能に関連するキーワード"
→ 類似機能や参考になる既存実装を発見
```

例:
- 認証機能を追加 → `grepai search "authentication handling"`
- エラー処理を改善 → `grepai search "error handling patterns"`

#### Step 3: 具体的なシンボルの調査（Serena）

```
mcp__serena__find_symbol "関連クラス/関数名"
mcp__serena__find_referencing_symbols "シンボル名"
→ 定義と参照を追跡し、影響範囲を特定
```

#### Step 4: 調査結果を整理

```markdown
## コードベース調査結果

### 関連する既存コード（Serena で特定）
- `src/auth/login.ts`: 認証ロジック
- `src/components/LoginForm.tsx`: UIコンポーネント

### 類似パターン（grepai で発見）
- `src/services/payment.ts`: 同様のバリデーションパターン
- `src/utils/errorHandler.ts`: エラーハンドリングの参考実装

### 影響範囲
- 変更が必要なファイル: 3件
- 依存しているコード: 5箇所

### 既存パターン
- 認証: JWT + Cookie
- バリデーション: zod
- テスト: vitest
```

> この調査結果をPhase 2以降で活用する

### Phase 2: スコープの絞り込み

YAGNI原則を適用し、以下を明確にする：

- **必須機能（Must have）**: なければ目的を達成できないもの
- **あれば良い機能（Nice to have）**: 今回のスコープから除外を検討
- **不要な機能**: 明示的に「やらないこと」として記録

質問例：
> 「〇〇の機能は本当に初期リリースに必要ですか？後から追加することも可能です」

### Phase 3: アプローチの提示

必ず**2〜3つの異なる実装アプローチ**を提示する：

```markdown
## アプローチ比較

| 観点 | アプローチA | アプローチB | アプローチC |
|------|-------------|-------------|-------------|
| 概要 | ... | ... | ... |
| メリット | ... | ... | ... |
| デメリット | ... | ... | ... |
| 適するケース | ... | ... | ... |
```

ユーザーに選択を求め、選択理由も確認する。

### Phase 4: タスクの分解（Decomposition）

選択されたアプローチを**自己完結的な小さなタスク**に分解する。

#### タスクの品質基準

| 基準 | 説明 |
|------|------|
| **Self-contained** | タスクの説明だけで実行可能（コンテキスト不要） |
| **Specific** | 曖昧さがない、具体的なアクション |
| **Achievable** | 5〜30分で完了できる粒度 |
| **Atomic** | 単一の作業単位、単一責任 |

#### タスク説明のフォーマット

各タスクには以下の情報を含める：

```markdown
## タスク: [具体的なアクション動詞] + [対象]

### What（何をするか）
- 具体的なアクション（明確な動詞で始める）
- 例: 「UserRepositoryクラスにfindByEmailメソッドを追加する」

### Where（どこで）
- ファイルパス: `src/repositories/UserRepository.ts`
- 変更箇所: クラス末尾に新規メソッド追加

### How（どのように）
- 既存パターンを参照: `findById`メソッドと同様の構造
- 使用するライブラリ/API: Prisma の `findUnique`

### Why（なぜ）
- 目的: メールアドレスでユーザーを検索する機能が必要
- 依存元: 認証フローで使用

### Verify（検証方法）
- [ ] `pnpm test src/repositories/UserRepository.test.ts` が通る
- [ ] 存在するメールで User が返る
- [ ] 存在しないメールで null が返る
```

#### 分解のステップ

1. **コンポーネント識別**: 機能を主要な要素に分割
2. **依存関係マッピング**: 実行順序を決定
3. **粒度調整**: 5〜30分に収まるよう分割/統合
4. **自己完結性確認**: 説明だけで実行可能か検証

#### タスク構成案の例

```markdown
## タスク構成案

### 1. UserRepositoryにfindByEmailを追加
- **What**: findByEmailメソッドを実装
- **Where**: `src/repositories/UserRepository.ts`
- **How**: findByIdと同様、Prisma findUnique使用
- **Why**: 認証でメール検索が必要
- **Verify**: ユニットテストが通る
- **依存**: なし
- **見積**: 15分

### 2. 認証サービスにログイン処理を追加
- **What**: loginメソッドを実装
- **Where**: `src/services/AuthService.ts`
- **How**: findByEmail → パスワード検証 → JWT生成
- **Why**: ユーザーログイン機能の実現
- **Verify**: 正常系・異常系テストが通る
- **依存**: タスク1
- **見積**: 25分
```

#### 粒度の目安

| 粒度 | 対応 |
|------|------|
| 5分未満 | 他のタスクと統合を検討 |
| 5〜30分 | 適切 |
| 30分超 | さらに分割を検討 |

### Phase 5: タスク管理システムへの登録

ユーザー承認後、`TaskCreate` と `TaskUpdate` を使用してタスクを登録：

```
各タスクに含める情報:

subject: タスクのタイトル（命令形 + 対象）
  例: "UserRepositoryにfindByEmailメソッドを追加"

description: What/Where/How/Why/Verify形式
  ## What
  findByEmailメソッドを実装する

  ## Where
  `src/repositories/UserRepository.ts`

  ## How
  - findByIdメソッドと同様の構造
  - Prisma の findUnique を使用

  ## Why
  認証フローでメールアドレスによるユーザー検索が必要

  ## Verify
  - [ ] `pnpm test UserRepository.test.ts` が通る
  - [ ] 存在するメールで User が返る
  - [ ] 存在しないメールで null が返る

activeForm: 進行中の表示文（現在進行形）
  例: "findByEmailメソッドを追加中"
```

#### 登録時のチェック

- [ ] 各タスクは5〜30分で完了可能か
- [ ] descriptionだけで実行可能か（自己完結性）
- [ ] Verifyが具体的で検証可能か
- [ ] 依存関係は正しく設定されているか

```
依存関係の設定:
- TaskUpdate で addBlockedBy / addBlocks を設定
- 並列実行可能なタスクを特定
```

### Phase 6: TDDで実装開始（必須）

**⚠️ 重要: 実装は必ず `/TDD` スキルを通じて行う**

```
┌─────────────────────────────────────────────────────────────┐
│  Planning完了後の実装フロー                                 │
│                                                             │
│  1. TaskList でブロックされていないタスクを確認             │
│  2. TaskUpdate で status: "in_progress" に更新              │
│  3. /TDD スキルを呼び出し、RED-GREEN-REFACTORで実装        │
│  4. /verify full で品質検証                                 │
│  5. TaskUpdate で status: "completed" に更新                │
│  6. 次のタスクへ                                            │
│                                                             │
│  全タスク完了後:                                            │
│  7. /verify full で最終検証                                 │
│  8. PR作成                                                  │
└─────────────────────────────────────────────────────────────┘
```

**フロー図:**

```
/planning → タスク登録
    ↓
/TDD (各タスク)
    ↓
/verify full (タスク完了前)
    ↓
全タスク完了
    ↓
/verify full (最終検証)
    ↓
PR作成
```

**実装開始時のメッセージ例:**

```
計画が完了しました。

## 登録されたタスク
1. [タスクA] データベーススキーマを作成
2. [タスクB] APIエンドポイントを実装
3. ...

## 次のステップ

実装を開始するには `/TDD` を実行してください。
TDDスキルがRED-GREEN-REFACTORサイクルで実装をガイドします。

> /TDD
```

---

## 重要な原則

1. **一度に1つの質問** - 複数の質問を同時にしない
2. **選択肢を提示** - 可能な限り選択式で質問する
3. **仮定を明示** - 判断に迷う場合は仮定を明示して確認を取る
4. **小さく始める** - 最小限の実装から始め、段階的に拡張する方針を推奨
5. **コードを書かない** - 計画フェーズではコードを書かず、計画に集中する
6. **依存関係を明確に** - タスク間の依存を正しく設定し、並列実行可能なものを特定する
7. **自己完結的なタスク** - descriptionだけで実行可能な詳細を含める（What/Where/How/Why/Verify）
8. **適切な粒度** - 各タスクは5〜30分で完了できるサイズに分解する
9. **TDDを強制** - 実装は必ず `/TDD` スキルを通じて行う
