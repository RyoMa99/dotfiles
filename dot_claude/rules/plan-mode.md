# Plan モードの進め方

Plan モード（EnterPlanMode）に入った場合、以下の5フェーズで進める。

---

## Phase 0: ローカルブランチの最新化チェック

Plan モードに入ったら、最初にリポジトリの状態を確認する。
ベースブランチが古いまま計画を立てると、調査結果が実態と乖離するリスクがある。

### 手順

```bash
# 1. リモートの最新情報を取得
git fetch origin

# 2. ベースブランチとリモートの差分を確認
#    （ユーザーが特定ブランチを指定している場合はそのブランチ、なければデフォルトブランチ）
git log --oneline HEAD..origin/main | head -20
```

### 判断基準

| ローカルとリモートの差 | 対応 |
|---------------------|------|
| 差分なし | そのまま Phase 1 へ進む |
| 数コミットの差 | ユーザーに報告し、`git pull` を提案。承認後に最新化して Phase 1 へ |
| 大きな差（10+ コミット、または変更ファイルが多い） | **計画に入らず停止**。最新化を促し、必要に応じてコンフリクトの解消を先に行う |

### 未コミットの変更がある場合

`AskUserQuestion` で確認する（stash / commit / discard）。
未コミットの変更を把握しないまま Phase 1 に進まない。

> 作業ブランチの作成は実装フェーズのタスク0で行う（`implementation.md` 参照）。

---

## Phase 1: 意図の明確化

調査に入る前に、ユーザーが何を達成したいかを明確にする。

- ユーザーの要求を自分の言葉で言い換え、認識が合っているか確認する
- 曖昧な点は `AskUserQuestion` で質問する（実装方針、優先度、制約など）
- 以下を明確にしてから Phase 2 に進む：
  - **ゴール**: 何を実現したいか
  - **文脈**: 誰が・どんな状況で使う機能か（利用者像・利用頻度・運用環境）
  - **制約**: 技術的制約、時間的制約、互換性要件
  - **スコープ**: 今回やること・やらないこと

> Phase 1 を省略しない。調査対象が明確でないまま Phase 2 に入ると、無関係なコードを読む時間が無駄になる。
> ただし、ユーザーが「軽微な修正」と判断しスキップを指示した場合は省略可。

### タスク性質の仮判定

Phase 2 の調査方針と Phase 3 の計画粒度を決めるため、タスクの性質を仮判定する。

| 性質 | 特徴 | 例 |
|------|------|-----|
| **探索的** | 正解が不明、試行錯誤が前提 | PoC、技術検証、新ライブラリ評価 |
| **既知パターン** | 十分な前例がある定型作業 | CRUD、設定ファイル追加、マイグレーション |
| **高リスク** | 失敗時の影響が大きい | 認証、決済、データ移行、破壊的変更 |

> 仮判定は Phase 2 の調査結果で見直す。ここでは初期仮説として設定する。

---

## Phase 2: コードベース調査

Phase 1 で明確になったゴールに基づき、既存コードを調査する。

### 調査ツールの使い分け

@~/.claude/rules/code-search.md の判断フローに従う。

特に以下を積極的に活用する：

1. **Serena** - シンボル概要の把握、定義・参照の追跡
   - `get_symbols_overview`: プロジェクト構造の把握
   - `find_symbol`: 関連クラス・関数の特定
   - `find_referencing_symbols`: 影響範囲の特定
2. **grepai** - セマンティック検索で類似パターン発見（クエリは英語で）
3. **Grep / Glob** - パターンマッチによる検索

### 調査で明らかにすべきこと

- 変更が必要なファイルと影響範囲
- 既存の設計パターン・慣習
- 類似機能の既存実装（参考にできるコード）
- 新しいドメイン概念が登場する場合は `/domain-modeling` スキルを参照しモデルを整理する
- 設計方針の選択肢（複数ある場合）

### 設計選択肢の比較

複数の設計方針がある場合は比較表を作成し、`AskUserQuestion` でユーザーに選択を仰いでから Phase 3 に進む。

```markdown
| 選択肢 | メリット | デメリット | 適合する文脈 |
|--------|---------|----------|------------|
| A: ... | ...     | ...      | ...        |
| B: ... | ...     | ...      | ...        |
```

> 選択肢が1つしかない場合（技術的に一択）はスキップしてよい。

### タスク性質の確定

Phase 1 の仮判定を調査結果で見直し、確定する。

- 仮判定と変わらない場合はそのまま Phase 3 に進む
- 変わった場合は理由を明記する（例: 「既知パターンと仮判定したが、既存実装に前例がなく探索的に変更」）

---

## Phase 3: 計画策定

Phase 1 の意図と Phase 2 の調査結果に基づき、実装計画を作成する。

### 計画の保存

プロジェクトに `docs/plan/` ディレクトリがある場合、計画をセマンティックバージョニングで保存する。
`ExitPlanMode` する前に、計画ファイルが保存されていることを確認する。

計画ファイルの保存は**タスク0**として計画に含める。実装フェーズで最初に実行されるタスクとして明示する。

#### バージョニング基準

`vMAJOR.MINOR.PATCH.md` 形式。セマンティックバージョニングに準拠する。

| 変更種別 | バージョン | 例 |
|---------|-----------|-----|
| **MAJOR** | 破壊的変更・アーキテクチャ刷新 | v1.0.0 → v2.0.0 |
| **MINOR** | 新機能追加（後方互換あり） | v0.1.0 → v0.2.0 |
| **PATCH** | バグ修正・リファクタ・設定変更 | v0.1.0 → v0.1.1 |

- 初回リリースは `v0.1.0`
- 既存の計画ファイルから最新バージョンを確認し、変更種別に応じてインクリメントする

### 計画の粒度（タスク数で判断）

| 規模 | タスク数目安 | 計画の粒度 |
|------|------------|-----------|
| **Small** | 1-2 | 受入条件のみ。I/O シグネチャ省略可 |
| **Medium** | 3-5 | フルフォーマット（I/O シグネチャ + 受入条件） |
| **Large** | 6+ | フルフォーマット + アーキテクチャ図・設計判断の根拠 |

### 性質による粒度の較正

タスク数ベースの粒度を、Phase 2 で確定したタスク性質で較正する。

| 性質 | 較正の方向 |
|------|-----------|
| **探索的** | 受入条件より**検証仮説**を重視。I/O シグネチャは暫定で可。「何を検証し、成功/失敗の判断基準は何か」を明記する |
| **既知パターン** | Phase 2 を軽量化し、既存実装の参照で十分。計画は Small 寄りに簡素化してよい |
| **高リスク** | タスク数に関わらず I/O シグネチャ・セキュリティ観点・ロールバック手順を必須とする |

> 性質とタスク数が矛盾する場合（例: 高リスクだがタスク1つ）は、性質側を優先する。

### 共通事項

- 具体的な変更対象（ファイル・シンボル）を列挙
- タスクを依存関係に基づき順序付け
- リスクや判断が必要なポイントを明示

### タスク定義のフォーマット

#### Medium / Large の場合

```markdown
### タスク N: [タスク名]

**変更対象**: ファイル・シンボル
**I/O シグネチャ**: 引数の型 → 戻り値の型

**受入条件**（TDD のテストリストになる）:
- WHEN [条件] THEN [期待動作]（正常系）
- WHEN [異常条件] THEN [エラー動作]（異常系）

**依存**: タスク M が完了後に着手
```

> I/F を計画段階で決めることで、AI実装の精度が大幅に向上する（SDD: Spec-Driven Development の知見）。

#### Small の場合

```markdown
### タスク N: [タスク名]

**変更対象**: ファイル・シンボル

**受入条件**:
- WHEN [条件] THEN [期待動作]（正常系）
- WHEN [異常条件] THEN [エラー動作]（異常系）
```

> I/O シグネチャは省略可。ただし型設計が重要な場合（新しいドメイン型の導入等）は Small でも記載する。

> 受入条件は `/TDD` スキル内のテスト原則（テスト観点表）に相当する。
> ここで正常系・異常系・境界値を洗い出しておくことで、TDD Phase 1（テスト設計）の精度が上がる。

---

## Phase 4: 計画レビュー（自己レビュー）

Phase 3 の計画を、シニアエンジニアの視点で自己レビューする。
`ExitPlanMode` の前に必ず実施する。

### レビュー観点

レビュー範囲は Phase 3 で判断した計画の規模に連動する。

#### 必須（全規模で実施）

1. **複雑性の妥当性**（最優先）
   - この要件に対してこの複雑さは妥当か？
   - より単純な解決策はないか？
   - 不要な作業を生み出していないか？

7. **計画内部の一貫性**
   - スコープ（Phase 1）とタスク分割のカバー範囲が一致しているか
   - 型定義・インターフェース設計と、テスト戦略で想定している型が整合しているか
   - ファイル構成が複数箇所で言及されている場合、矛盾していないか

#### Medium 以上で実施

2. **保守性・一貫性**
   - 類似機能の既存実装スタイルと整合しているか
   - 命名規則・ディレクトリ構成・エラーハンドリング方針

3. **完全性**
   - 各要件を「WHEN [条件] THEN [動作]」形式で書けるか？書けないなら曖昧
   - エッジケース・エラーハンドリングの考慮

4. **リスク**
   - 破壊的変更の影響範囲
   - パフォーマンス・セキュリティ

5. **テスト戦略（TDD 実行可能性）**
   - 各タスクの受入条件がテストとして実装可能か
   - 受入条件から RED-GREEN-REFACTOR サイクルが想定できるか
   - 正常系と同数以上の異常系が含まれているか

6. **段階分割**
   - タスクサイズは TDD サイクル（1タスク = 数回の RED-GREEN-REFACTOR）に適しているか
   - 各タスクがどの要件を満たすか追跡可能か

### 過去の学びを参照

レビュー時に以下を確認し、過去の失敗を繰り返さないようにする：
- `{project}/.claude/rules/plan-review.md`（プロジェクト固有、存在する場合）

### 指摘の形式

問題がある場合は **重要度 → 問題 → 理由 → 代替案** で提示する。

重要度の分類：
- **Critical**: 実装着手不可。設計の根本に関わる問題（例: スコープの矛盾、不可能な要件）
- **Major**: 実装前に解決すべき。品質やスケジュールに大きく影響（例: エッジケース未考慮）
- **Minor**: 改善推奨だが実装は可能（例: 命名の改善、テストケースの追加）

```
❌ [Critical/Major/Minor] 問題: [何が問題か]
   理由: [なぜ問題か]
   代替案: [どうすべきか]
```

### 較正メモ

計画ファイルに以下の形式で較正の判断根拠を記録する。振り返り（session-retrospective）での検証材料になる。

```markdown
## 較正メモ

- **タスク性質**: [探索的 / 既知パターン / 高リスク]
- **重視した観点**: [例: 検証速度を重視し、型安全性は暫定対応とした]
- **軽視した観点**: [例: エッジケースの網羅は PoC 段階では不要と判断]
- **理由**: [なぜその較正が妥当か]
```

> 較正メモは計画ファイルに含める（`docs/plan/` に保存される場合はそこに記載）。

### レビュー後

- 問題がなければ `ExitPlanMode` でユーザーの承認を得る
- Critical/Major があれば計画を修正し、再度レビューしてから `ExitPlanMode`
- **反復は最大3回**。3回で解消しない場合はユーザーに判断を仰ぐ
- Minor のみの場合は指摘を明記した上で `ExitPlanMode` してよい
- 重要な学びがあれば plan-mode.md を直接改善するか、`/session-retrospective` で振り返る
