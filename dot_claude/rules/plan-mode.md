---
alwaysApply: true
---

# Plan モードの進め方

> **Override**: このルールは Claude Code ビルトインの Plan Mode ワークフローを上書きする。
> EnterPlanMode 後は、ビルトインのフェーズ（Initial Understanding → Design → Review → Final Plan）ではなく、以下の Phase 0-4 に従う。

Plan モード（EnterPlanMode）に入った場合、以下の5フェーズで進める。

---

## Phase 0: ローカルブランチの最新化チェック

Plan モードに入ったら、最初にリポジトリの状態を確認する。
ベースブランチが古いまま計画を立てると、調査結果が実態と乖離するリスクがある。

### 手順

```bash
# 1. リモートの最新情報を取得
git fetch origin

# 2. ベースブランチとリモートの差分を確認
#    （ユーザーが特定ブランチを指定している場合はそのブランチ、なければデフォルトブランチ）
DEFAULT_BRANCH=$(gh repo view --json defaultBranchRef -q '.defaultBranchRef.name')
git log --oneline HEAD..origin/$DEFAULT_BRANCH | head -20
```

### 判断基準

| ローカルとリモートの差 | 対応 |
|---------------------|------|
| 差分なし | そのまま Phase 1 へ進む |
| 数コミットの差 | ユーザーに報告し、`git pull` を提案。承認後に最新化して Phase 1 へ |
| 大きな差（10+ コミット、または変更ファイルが多い） | **CRITICAL: 計画に入らず停止**。最新化を促し、必要に応じてコンフリクトの解消を先に行う |

### 未コミットの変更がある場合

`AskUserQuestion` で確認する（stash / commit / discard）。
未コミットの変更を把握しないまま Phase 1 に進まない。

> **Gate**: ベースブランチがリモートと同期済み、かつ未コミットの変更が解消されていること（`git status` / `git log` で自己チェック）

---

## Phase 1: 意図の明確化

調査に入る前に、ユーザーが何を達成したいかを明確にする。

- ユーザーの要求を自分の言葉で言い換え、認識が合っているか確認する
- 曖昧な点は `AskUserQuestion` で質問する（実装方針、優先度、制約など）
- 以下を明確にしてから Phase 2 に進む：
  - **ゴール**: 何を実現したいか
  - **文脈**: 誰が・どんな状況で使う機能か（利用者像・利用頻度・運用環境）
  - **制約**: 技術的制約、時間的制約、互換性要件、NFR（性能・セキュリティ・可観測性）
  - **スコープ**: 今回やること・やらないこと（除外理由も記録する）

> IMPORTANT: Phase 1 を省略しない。ユーザーが明示的に「Phase 1 スキップ」と指示した場合のみ省略可。
> 調査対象が明確でないまま Phase 2 に入ると、無関係なコードを読む時間が無駄になる。

### タスク性質の仮判定

Phase 2 の調査方針と Phase 3 の計画粒度を決めるため、タスクの性質を仮判定する。

| 性質 | 特徴 | 例 |
|------|------|-----|
| **探索的** | 正解が不明、試行錯誤が前提 | PoC、技術検証、新ライブラリ評価 |
| **既知パターン** | 十分な前例がある定型作業 | CRUD、設定ファイル追加、マイグレーション |
| **高リスク** | 失敗時の影響が大きい | 認証、決済、データ移行、破壊的変更 |

> 性質は複合しうる（例: 探索的 + 高リスク = 新しい認証方式の導入）。複合する場合は最も厳格な性質を主として較正する（高リスク > 探索的 > 既知パターン）。

> 仮判定は Phase 2 の調査結果で見直す。ここでは初期仮説として設定する。

> **Gate**: ゴール・文脈・制約・スコープの4項目がユーザーと合意されていること（`AskUserQuestion` で明示的に確認）

---

## Phase 2: コードベース調査

Phase 1 で明確になったゴールに基づき、既存コードを調査する。

### 調査ツールの使い分け

@~/.claude/rules/code-search.md の判断フローに従う。
構造把握には Serena、意味検索には grepai、パターン検索には Grep/Glob を使い分ける。

### 調査で明らかにすべきこと

- 変更が必要なファイルと影響範囲
- 既存の設計パターン・慣習
- 類似機能の既存実装（参考にできるコード）
- 新しいドメイン概念が登場する場合は `/domain-modeling` スキルを参照しモデルを整理する
- 設計方針の選択肢（複数ある場合）

### 設計選択肢の比較

複数の設計方針がある場合は比較表（選択肢 / メリット / デメリット / 適合する文脈）を作成し、`AskUserQuestion` でユーザーに選択を仰ぐ。選択肢が1つしかない場合（技術的に一択）はスキップしてよい。不可逆な設計判断や多角的検証が必要な場合は @~/.claude/rules/agent-team.md の Agent Team 編成も検討する。

### 調査スコープの目安

タスク性質に応じて調査の深さを調整する。

| 性質 | 調査スコープ |
|------|-------------|
| **既知パターン** | 類似実装1件の確認で十分。パターンが確認できたら調査終了 |
| **探索的** | 関連コード2-3箇所を横断的に調査。技術的実現可能性の確認を含む |
| **高リスク** | 影響範囲の網羅的な特定。依存先・依存元の洗い出し、既存テストカバレッジの確認 |

### タスク性質の確定

Phase 1 の仮判定を調査結果で見直し、確定する。

- 仮判定と変わらない場合はそのまま Phase 3 に進む
- 変わった場合は理由を明記する（例: 「既知パターンと仮判定したが、既存実装に前例がなく探索的に変更」）

> **Gate**: 変更対象ファイル・影響範囲が特定され、タスク性質が確定していること（自己チェック）

---

## Phase 3: 計画策定

Phase 1 の意図と Phase 2 の調査結果に基づき、実装計画を作成する。

### 計画の保存

プロジェクトに `docs/plan/` ディレクトリがある場合、計画をセマンティックバージョニングで保存する。

> IMPORTANT: `ExitPlanMode` する前に、計画ファイルが保存されていることを確認する。

計画ファイルの保存は**タスク0**として計画に含める。実装フェーズで最初に実行されるタスクとして明示する。

#### バージョニング基準

`vMAJOR.MINOR.PATCH.md` 形式。セマンティックバージョニングに準拠する。

| 変更種別 | バージョン | 例 |
|---------|-----------|-----|
| **MAJOR** | 破壊的変更・アーキテクチャ刷新 | v1.0.0 → v2.0.0 |
| **MINOR** | 新機能追加（後方互換あり） | v0.1.0 → v0.2.0 |
| **PATCH** | バグ修正・リファクタ・設定変更 | v0.1.0 → v0.1.1 |

- 初回リリースは `v0.1.0`
- 既存の計画ファイルから最新バージョンを確認し、変更種別に応じてインクリメントする

#### 計画ファイルのヘッダー

```markdown
# [計画タイトル]
- **バージョン**: vX.Y.Z
- **作成日**: YYYY-MM-DD
- **ベースブランチ**: main
- **タスク性質**: 探索的 / 既知パターン / 高リスク
- **ゴール**: [Phase 1 で合意した達成目標]
- **スコープ**: [やること / やらないこと]
- **制約**: [技術的制約、互換性要件、NFR 等]
```

### 計画の粒度（タスク数で判断）

| 規模 | タスク数目安 | 計画の粒度 |
|------|------------|-----------|
| **Small** | 1-2 | 受入条件のみ。I/O シグネチャ省略可 |
| **Medium** | 3-5 | フルフォーマット（I/O シグネチャ + 受入条件） |
| **Large** | 6+ | フルフォーマット + アーキテクチャ図・設計判断の根拠 |

### 性質による粒度の較正

タスク数ベースの粒度を、Phase 2 で確定したタスク性質で較正する。

| 性質 | 較正の方向 |
|------|-----------|
| **探索的** | 受入条件より**検証仮説**を重視。I/O シグネチャは暫定で可。「何を検証し、成功/失敗の判断基準は何か」を明記する。不確実性が高い場合は Spike タスク（時間制限付き調査、成果物は判断材料）を計画に含める |
| **既知パターン** | Phase 2 を軽量化し、既存実装の参照で十分。計画は Small 寄りに簡素化してよい |
| **高リスク** | タスク数に関わらず I/O シグネチャ・セキュリティ観点・ロールバック手順を必須とする |

> 性質とタスク数が矛盾する場合（例: 高リスクだがタスク1つ）は、性質側を優先する。

### 共通事項

- 具体的な変更対象（ファイル・シンボル）を列挙
- タスクを依存関係に基づき順序付け
- リスクや判断が必要なポイントを明示

### タスク定義のフォーマット

```markdown
### タスク N: [タスク名]

**変更対象**: ファイル・シンボル
**I/O シグネチャ**: 引数の型 → 戻り値の型（Small は省略可）

**受入条件**（TDD のテストリストになる）:
- WHEN [条件] THEN [期待動作]（正常系）
- WHEN [境界条件] THEN [期待動作]（境界値）
- WHEN [異常条件] THEN [エラー動作]（異常系）

**リスク**: [リスクがある場合] → **軽減策**: [対策]
**依存**: タスク M が完了後に着手
```

> I/F を計画段階で決めることで、AI実装の精度が大幅に向上する（SDD: Spec-Driven Development の知見）。
> 型設計が重要な場合（新しいドメイン型の導入等）は Small でも I/O シグネチャを記載する。
> 受入条件は `/TDD` スキル内のテスト原則（テスト観点表）に相当する。正常系・異常系・境界値を洗い出すことで TDD Phase 1 の精度が上がる。

> **Gate**: 計画ファイルが作成済み、かつ全タスクに受入条件が定義されていること（自己チェック）

---

## Phase 4: 計画レビュー（自己レビュー）

Phase 3 の計画を、シニアエンジニアの視点で自己レビューする。
IMPORTANT: `ExitPlanMode` の前に必ず実施する。

### レビュー観点

レビュー範囲は Phase 3 で判断した計画の規模に連動する。

#### 必須（全規模で実施）

- **複雑性の妥当性**（最優先）: この要件に対してこの複雑さは妥当か？より単純な解決策はないか？
- **計画内部の一貫性**: スコープとタスク分割のカバー範囲、型定義とテスト戦略の整合性

#### Medium 以上で実施

- **保守性・一貫性**: 既存実装スタイル・命名規則・ディレクトリ構成との整合
- **完全性**: 各要件を「WHEN [条件] THEN [動作]」で書けるか？エッジケースの考慮
- **リスク**: 破壊的変更の影響範囲、パフォーマンス・セキュリティ
- **テスト戦略**: 受入条件が TDD で実装可能か、正常系と同数以上の異常系が含まれるか
- **段階分割**: タスクサイズが TDD サイクルに適しているか、要件への追跡可能性

### 指摘の形式

問題がある場合は **重要度 → 問題 → 理由 → 代替案** で提示する。

重要度の分類：
- **Critical**: 実装着手不可。設計の根本に関わる問題（例: スコープの矛盾、不可能な要件）
- **Major**: 実装前に解決すべき。品質やスケジュールに大きく影響（例: エッジケース未考慮）
- **Minor**: 改善推奨だが実装は可能（例: 命名の改善、テストケースの追加）

```
❌ [Critical/Major/Minor] 問題: [何が問題か]
   理由: [なぜ問題か]
   代替案: [どうすべきか]
```

### 較正メモ

計画ファイルの末尾に較正メモセクションを記録する。振り返り（session-retrospective）での検証材料になる。

```markdown
## 較正メモ
- **タスク性質**: [確定した性質（複合の場合は主/副を明記）]
- **重視した観点**: [例: セキュリティ、後方互換性]
- **軽視した観点**: [例: パフォーマンス最適化は後回し]
- **理由**: [上記の判断根拠]
```

### レビュー後

- 問題がなければ `ExitPlanMode` でユーザーの承認を得る
- Critical/Major があれば計画を修正し、再度レビューしてから `ExitPlanMode`
- 重要な学びがあれば plan-mode.md を直接改善するか、`/session-retrospective` で振り返る

> **計画承認後**: ユーザーが計画を承認したら、`/implementation` スキルを実行して計画を遂行する。

### 計画却下時のフロー

`ExitPlanMode` 後にユーザーが計画を却下した場合、却下理由に応じて再突入先を決める。

| 却下理由 | 再突入先 |
|---------|---------|
| ゴール・スコープの変更 | Phase 1 に戻り、意図を再確認 |
| アプローチ・設計方針の変更 | Phase 2-3 を再実施 |
| 細部の修正（タスク分割、受入条件等） | Phase 3-4 のみ再実施 |
