# テストの原則

t_wada（和田卓人）氏の自動テストに関する知見をベースにした原則集。

---

## 自動テストの目的

> 信頼性の高い実行結果に短時間で到達する状態を保つことで、
> 開発者に**根拠ある自信**を与え、ソフトウェアの成長を持続可能にすること

テストの価値は「コスト削減」ではなく「変化に対応する力」を得ること。

---

## テストの信頼性：偽陽性と偽陰性

信頼できるテストとは「嘘がないテスト」。嘘には2種類ある。

### 偽陽性（False Positive）

**コードは正しいのにテストが失敗する**

```
火が出ていないのに火災報知器が鳴る状態
```

パターン:
- **Flaky Test（信頼不能テスト）**: コードに触れていないのに結果が不安定
- **Brittle Test（脆いテスト）**: 実装の詳細変更でテストが壊れる

対策:
- 実装の詳細ではなく、振る舞いをテストする
- 時間やランダム性に依存しない設計
- テストダブルの適切な使用

### 偽陰性（False Negative）

**バグがあるのにテストが成功する**

```
火が出ているのに火災報知器が鳴らない状態
```

パターン:
- カバレッジ不足
- `skip` されたまま放置されたテスト
- テストコードがプロダクトコードのバグを再現している

対策:
- テストリストで網羅性を確保
- 境界値・異常系のテストを必ず含める
- ミューテーションテストの活用

---

## テストサイズ（Small / Medium / Large）

「単体テスト」「結合テスト」は定義がブレる。代わりにサイズで分類する。

| サイズ | 制約 | 実行速度 | 信頼性 |
|--------|------|----------|--------|
| **Small** | 単一プロセス、外部アクセスなし | 最速 | 最高 |
| **Medium** | 単一マシン、ローカルDB/コンテナ可 | 中程度 | 高 |
| **Large** | 制約なし、外部システム接続可 | 遅い | 変動あり |

### 推奨される配置

```
ドメインロジック    → Small × 単体
Controller/Service → Small × 統合（テストダブル使用）
Repository         → Medium × 単体（Fake DB使用）
E2E               → Large（最小限に）
```

### テストピラミッド

```
        /\
       /  \  Large（少）
      /----\
     /      \  Medium
    /--------\
   /          \  Small（多）
  --------------
```

逆三角形（アイスクリームコーン）は避ける。E2Eが多すぎると遅く不安定になる。

---

## テストダブルの役割

テストダブルの最重要目的は**テストサイズを下げること**。

| 種類 | 用途 |
|------|------|
| **Fake** | 本物の簡易版（DynamoDB Local、LocalStack等） |
| **Stub** | 固定値を返す |
| **Mock** | 呼び出しを検証（使いすぎ注意） |

### Fakeでサイズを下げる

```
Large（本番DB）→ Medium（Fake DB）→ Small（インメモリ）
```

Dockerを使うとSmallからMediumに上がる。数が増えると実行時間が掛け算で増える。

### Mockの注意点

Mockを多用すると:
- 実装の詳細に依存（Brittle Test化）
- 自己検証的なテストになりやすい

振る舞いの検証にはFakeを優先する。

---

## 良いテストの書き方

### テストコードも本番コードと同じ品質で

テストコードだから簡易的に書いてよい、ではない。
メンテナンスし続けるコードとして質を追求する。

### AAA パターン

```
Arrange（準備）→ Act（実行）→ Assert（検証）
```

各セクションを明確に分離する。

### テスト名は振る舞いを記述

```typescript
// BAD: 実装の詳細
it('setStateが呼ばれる')

// GOOD: 振る舞い
it('ログインボタンをクリックするとダッシュボードに遷移する')
```

### 1テスト1アサーション（原則）

複数のアサーションがあると、最初の失敗で止まり、全体像が見えない。

---

## テスト実装の手順

### 1. テスト観点表を先に作る

テストコードを書く前に、Markdown形式のテスト観点表を作成する。

| Case ID | Input / Precondition | Perspective | Expected Result | Notes |
|---------|---------------------|-------------|-----------------|-------|
| TC-N-01 | 有効な入力A | 等価分割 - 正常系 | 処理成功、期待値を返す | - |
| TC-A-01 | NULL | 境界値 - NULL | バリデーションエラー | - |
| TC-A-02 | 空文字 | 境界値 - 空 | バリデーションエラー | - |
| TC-B-01 | 最小値-1 | 境界値 - 下限外 | 範囲エラー | - |
| TC-B-02 | 最小値 | 境界値 - 下限 | 処理成功 | - |
| TC-B-03 | 最大値 | 境界値 - 上限 | 処理成功 | - |
| TC-B-04 | 最大値+1 | 境界値 - 上限外 | 範囲エラー | - |

**境界値チェックリスト**: `0 / 最小値 / 最大値 / ±1 / 空 / NULL`

### 2. 正常系と同数以上の失敗系

正常系だけでは偽陰性（バグを見逃す）リスクが高い。

```
正常系 : 失敗系 = 1 : 1以上
```

失敗系に含めるもの:
- バリデーションエラー
- 例外パス
- 不正な型・形式の入力
- 外部依存の失敗（API / DB）

### 3. Given / When / Then コメント

各テストケースにコメントを付与し、シナリオを追えるようにする。

```typescript
it('無効なメールアドレスでバリデーションエラーになる', () => {
  // Given: 不正な形式のメールアドレス
  const invalidEmail = 'not-an-email';

  // When: バリデーションを実行
  const result = validateEmail(invalidEmail);

  // Then: エラーが返される
  expect(result.isValid).toBe(false);
  expect(result.error).toBe('Invalid email format');
});
```

### 4. 例外・エラーの検証

例外が発生するケースでは、**型とメッセージ**を明示的に検証する。

```typescript
// BAD: 例外が投げられることだけ確認
expect(() => fn()).toThrow();

// GOOD: 例外の型とメッセージを検証
expect(() => fn()).toThrow(ValidationError);
expect(() => fn()).toThrow('Email is required');
```

### 5. カバレッジ目標

- **分岐網羅100%を目標**とする
- 達成が合理的でない場合は、ビジネスインパクトの高い分岐を優先
- 未カバーの分岐がある場合は、理由をPR本文に明記

---

## レガシーコードへのテスト追加

テストなしのコードを改善する際の戦略（t_wada）。

### ジレンマ

> テストがないと安全にコードを変更できない。
> しかしテストを書くにはコードを変更する必要がある。

### 解決アプローチ

#### 1. リクエスト/レスポンスレベルから始める

```
実装から距離を取りつつ、安定したテストを書ける
```

- 最初は完全一致を求めず、簡潔なアサーションから開始
- 入力と出力の関係をテストする（実装詳細に依存しない）

#### 2. Seam（継ぎ目）を見つける

依存性を外部から注入可能にして、テスト駆動で開発できる環境を整備：

```typescript
// BAD: ランダム性が内部に閉じている
function generateId() {
  return Math.random().toString(36);
}

// GOOD: ランダム性を注入可能に
function generateId(randomFn = Math.random) {
  return randomFn().toString(36);
}

// テスト時
generateId(() => 0.5); // 決定的な結果
```

#### 3. Extract戦略

既存コードを壊さずに、テスト可能なコードを抽出：

```
1. 既存コードにテストを書く（現状の動作を記録）
2. 新しいコードを段階的に抽出
3. 変更のタイミング・理由が同じものをまとめる
4. 異なるものは分離する
```

### ドメインとインフラの分離

```
┌─────────────────────────────────────┐
│  インフラ層（テスト困難）           │
│  - HTTP/Lambda/外部API              │
└─────────────────────────────────────┘
              ↓ 依存
┌─────────────────────────────────────┐
│  ドメイン層（テスト容易）           │
│  - ビジネスロジック                 │
│  - TDDで段階的に成長                │
└─────────────────────────────────────┘
```

ドメインをインフラから分離し、ドメインをテスト駆動で育てる。

---

## 参考資料

- [t_wada - 組織に自動テストを書く文化を根付かせる戦略](https://speakerdeck.com/twada/building-automated-test-culture-2024-winter-edition)
- [t_wada - 開発生産性の観点から考える自動テスト](https://speakerdeck.com/twada/automated-test-knowledge-from-savanna-202406-findy-dev-prod-con-edition)
- [t_wada - レガシーコード改善の実録](https://speakerdeck.com/twada/working-with-legacy-code-the-true-record)
- [TDDは「開発者テストのTips集」](https://levtech.jp/media/article/interview/detail_477/)
- [自動テストの「嘘」をなくす方法](https://levtech.jp/media/article/column/detail_496/)
