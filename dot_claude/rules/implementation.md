# 実装フェーズの進め方

Plan モードで承認された計画に基づいてコードを変更する際のルール。

---

## 1. ガードレール先行

個別タスクの実装に入る前に、プロジェクト全体のガードレールを整備する。

- 型定義・スキーマ定義を先に作成（計画の I/O シグネチャに基づく）
- テスト環境の確認（テストランナー、テストダブルの準備）

> 個別タスクのテスト作成は `/TDD` スキル内で行う。ここではプロジェクト全体の基盤を整備する。

---

## 2. タスク単位で TDD 実装

計画の各タスクを `/TDD` スキルで実装する。

- タスクの**受入条件**を TDD のテストリスト（Phase 1）として使用する
- `/TDD` の Phase 0（終了条件）は計画のタスク定義から導出する
- 独立したタスクが複数ある場合は `Task` ツールで並列実行を検討
- 各タスク完了時に `AskUserQuestion` でユーザーの確認を取る
- **ユーザーの OK なしに次タスクへ進まない**
- 確認時には変更差分・テスト結果など具体的な情報を提示する

> `/TDD` の各サイクルで型チェック・リント・テスト実行が行われる（VERIFY ループ）。

---

## 3. 完了前の検証（必須）

全タスク完了後、作業完了を宣言する前に以下を実行する。

> 各タスクの `/TDD` Phase 4 でタスク単位の検証は完了している前提。
> ここではタスク間の整合性と追加レビューを行う。

### 全体の整合性確認
- [ ] 全テストスイートを実行し、タスク間の干渉がないことを確認
- [ ] 型チェック・リントをプロジェクト全体で実行

### スキルによるレビュー（変更ファイルに対して実行）
- [ ] `/naming-review` - 変更したコードの命名をレビュー（常に実行）
- [ ] `/ui-check` - UIコンポーネントを変更した場合のみ実行

> 「テストが通りました」と言う前に、実際のコマンド出力を貼る。証拠なき主張はしない。

---

## 4. 完了の判断

すべての検証をパスしたら、ユーザーに完了方法を確認する。

- コミットのみ
- コミット + プッシュ
- コミット + プッシュ + PR 作成

ユーザーの指示なしにプッシュや PR 作成を行わない。

---

## 5. セッション後の振り返り

ユーザーが完了を確認した後、`/session-retrospective` を実行する。

4つの観点（ドメイン知識・技術的学び・自動化機会・既存知識の更新）で
セッションを1回で振り返り、保存先を振り分ける。

> ユーザー承認なしに保存しない。提案のみ行い、不要なら即スキップ。

個別に深掘りしたい場合は従来のスキルも使用可能：
- `/record-business-knowledge` - ドメイン知識の詳細記録
- `/sync-knowledge` - 技術的学びの詳細同期
- `/suggest-automation` - 自動化パターンの詳細検出
