# 実装フェーズの進め方

Plan モードで承認された計画に基づいてコードを変更する際のルール。

---

## 0. タスク0: 計画ファイル保存 + 作業ブランチ作成

計画が承認されたら、最初に実行するタスク。

### 作業ブランチの作成

```bash
# ベースブランチを最新化（Phase 0 で確認済みの状態を前提）
git checkout main && git pull origin main

# 作業ブランチを作成
git checkout -b <prefix>/<slug>
```

#### ブランチ命名規則

| prefix | 用途 | 例 |
|--------|------|-----|
| `feature/` | 新機能追加 | `feature/user-auth` |
| `fix/` | バグ修正 | `fix/login-redirect` |
| `refactor/` | リファクタリング | `refactor/api-layer` |
| `chore/` | CI, docs, 依存更新等の雑務 | `chore/ci-workflow` |

slug はケバブケースで簡潔に。計画の内容から適切な prefix と slug を選択する。

### 計画ファイルの保存

プロジェクトに `docs/plan/` がある場合、承認された計画をバージョニングして保存する。

---

## 1. ガードレール先行

個別タスクの実装に入る前に、プロジェクト全体のガードレールを整備する。

- 型定義・スキーマ定義を先に作成（計画の I/O シグネチャに基づく）
- テスト環境の確認（テストランナー、テストダブルの準備）

> 個別タスクのテスト作成は `/TDD` スキル内で行う。ここではプロジェクト全体の基盤を整備する。

---

## 2. タスク単位で TDD 実装

計画の各タスクを `/TDD` スキルで実装する。

- タスクの**受入条件**を TDD のテストリスト（Phase 1）として使用する
- `/TDD` の Phase 0（終了条件）は計画のタスク定義から導出する
- 独立したタスクが複数ある場合は `Task` ツールで並列実行を検討
- 各タスク完了時に `AskUserQuestion` でユーザーの確認を取る
- **ユーザーの OK なしに次タスクへ進まない**
- 確認時には変更差分・テスト結果など具体的な情報を提示する

> `/TDD` の各サイクルで型チェック・リント・テスト実行が行われる（VERIFY ループ）。

---

## 3-4. 完了前検証 → コミット → PR 作成

全タスク完了後、**`/finish` スキルを実行する**。

`/finish` は以下を一括実行する:
1. `/naming-review`（常に実行）
2. `/ui-check`（UI 変更時のみ）
3. 全テスト・型チェック・lint
4. 開発サーバーの停止確認
5. コミット方法をユーザーに確認

> `/finish` を経由せずにコミットしない。検証漏れを防ぐためのガードレール。

### PR 作成

`/finish` でコミットが完了したら、PR を作成する。

```bash
# 1. リモートにプッシュ
git push -u origin <branch-name>

# 2. PR 作成
gh pr create --title "<タイトル>" --body "<本文>"
```

- PR タイトルは70文字以内、変更内容を簡潔に
- 本文には `## Summary`（箇条書き）と `## Test plan`（検証チェックリスト）を含める
- タスク0 で作成した作業ブランチから main 向けに作成する
- ユーザーが「コミットのみ」「PR は後で」を選択した場合はスキップ

---

## 5. セッション後の振り返り

ユーザーが完了を確認した後、`/session-retrospective` を実行する。

4つの観点（ドメイン知識・技術的学び・自動化機会・既存知識の更新）で
セッションを1回で振り返り、保存先を振り分ける。

> ユーザー承認なしに保存しない。提案のみ行い、不要なら即スキップ。

個別に深掘りしたい場合は従来のスキルも使用可能：
- `/record-business-knowledge` - ドメイン知識の詳細記録
- `/sync-knowledge` - 技術的学びの詳細同期
- `/suggest-automation` - 自動化パターンの詳細検出
